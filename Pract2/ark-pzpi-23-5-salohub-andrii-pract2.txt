МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ




Звіт
з практичної роботи № 2 з дисципліни
Аналіз та рефакторинг коду





Виконала:                                                                         Перевірив:
ст. гр. ПЗПІ-23-5                        				ст. викладач кафедри ПІ
Салогуб Андрій 						          Сокорчук Ігор Петрович








Харків 2025


1 МЕТА РОБОТИ

1. Студент повинен обрати три методи рефакторингу коду із книги Мартіна Фаулера «Refactoring. Improving the Design of Existing Code».
2. Навести приклади свого особистого коду (з курсових, лабораторних або інших проєктів), який потребує покращення, та продемонструвати застосування обраних методів.
3. Кожен метод рефакторингу повинен супроводжуватись:
• Описом проблеми, яку вирішує даний метод.
• Кодом до і після застосування методу рефакторингу.
• Поясненням переваг використаного методу.
• 


2 ОПИС ВИКОНАНОЇ РОБОТИ

     У рамках цієї доповіді було обрано такі методи рефакторингу коду: Decompose Conditional, Replace Parameter with Explicit Methods та Substitute Algorithm. Застосування цих методів дозволяє покращити структуру програми, підвищити зрозумілість логіки та спростити подальше обслуговування коду.
     Рефакторинг загалом є процесом контрольованого вдосконалення внутрішньої структури програмного забезпечення без зміни його зовнішньої поведінки. Його мета полягає у створенні чистого, логічно послідовного та легкого для підтримки коду. У результаті покращується архітектура проєкту, зменшується кількість потенційних помилок і спрощується взаємодія між розробниками.
     Таким чином, рефакторинг виступає важливим етапом у життєвому циклі програмного забезпечення, адже забезпечує стабільність системи, полегшує внесення змін і сприяє підвищенню загальної якості продукту.
     Після розгляду загальної сутності рефакторингу доцільно перейти до аналізу конкретних методів, обраних у межах цієї роботи. Першим із них є Decompose Conditional (розкладання умовного виразу). Даний метод застосовується у випадках, коли програмний код містить складні або громіздкі умовні конструкції, що ускладнюють розуміння логіки програми. Замість використання великого виразу з кількома перевірками та логічними операціями, розробник розкладає його на менші частини, кожну з яких оформлює у вигляді окремого допоміжного методу з чіткою, змістовною назвою.
     Такий підхід значно підвищує читабельність коду, оскільки дозволяє легко зрозуміти, за яких умов виконується певна гілка логіки, не заглиблюючись у складні логічні зв’язки. Крім того, розкладання умов сприяє повторному використанню перевірок у різних частинах програми, зменшуючи дублювання коду. Це також спрощує процес тестування, адже кожен допоміжний метод можна перевірити окремо.

     А тепер перейдемо до практичного прикладу, щоб побачити, як метод Decompose Conditional може покращити якість програмного коду. Для демонстрації було використано частину коду з мого навчального проєкту, розробленого в межах дисципліни «Алгоритми та структури даних». У даному випадку розглядається функція, що реалізує обчислення станів алгоритму пошуку найдовшої зростаючої підпослідовності (LIS).
     Наведений нижче варіант є початковою версією коду (в додату В.1), у якій спостерігаються проблеми, пов’язані зі складними вкладеними умовами та недостатньою зрозумілістю логіки:
     Як видно код містить складну багаторівневу умовну конструкцію (рядки 6–35), у якій поєднано декілька логічно різних перевірок. Умови (рядки 6, 11 і 26) визначають різні етапи виконання алгоритму, однак вони розміщені в одному блоці, що робить загальну логіку неочевидною.
     Особливо важко сприймається вкладена перевірка на рядках 12–15, де відбувається порівняння елементів послідовності та оновлення проміжних результатів. Без контексту зрозуміти її призначення майже неможливо. Крім того, умова завершення алгоритму на рядку 26 виглядає відокремленою від загального потоку логіки — її роль стає зрозумілою лише після детального аналізу коду.
     Таке поєднання перевірок різного рівня абстракції є типовим прикладом ситуації, коли варто застосувати метод Decompose Conditional.
     Після застосування методу Decompose Conditional код було перебудовано з урахуванням принципів розділення логіки та підвищення читабельності. Усі складні перевірки були винесені в окремі допоміжні функції з чіткими назвами, що відображають їхню роль у процесі виконання алгоритму. Завдяки цьому основна функція getNextLisState стала значно зрозумілішою, а її логіка — більш послідовною.
     Оновлений варіант коду після рефакторингу наведено в додатку В.2. У цьому варіанті код став значно більш структурованим. Складні перевірки з попередньої версії (рядки 6–35 у старому коді) були винесені в окремі логічні функції — зокрема:
• isInitialState() (рядки 6–8) визначає початковий стан алгоритму замість перевірки outerIndex === -1;
• isProcessingInnerLoop() (рядки 10–12) спрощує умову обробки внутрішнього циклу;
• isAlgorithmComplete() (рядки 14–16) надає зрозумілу назву перевірці завершення алгоритму, яка раніше знаходилась у рядку 26 старого коду;
• shouldUpdateLIS() (рядки 26–32) об’єднує дві логічно пов’язані умови з попереднього вкладеного if (рядки 12–15 у старій версії), роблячи перевірку читабельною і самодокументованою.
     Завдяки цьому основна функція getNextLisState (рядки 34–68) тепер виглядає лаконічно й легко читається. Логіка виконання чітко відокремлена від умов перевірки станів, що підвищує розбірливість коду та полегшує тестування окремих частин алгоритму.
     Наступним методом, який було розглянуто в межах цієї роботи, є Replace Parameter with Explicit Methods. Цей підхід дозволяє зробити код більш зрозумілим і передбачуваним у тих випадках, коли одна функція виконує кілька різних дій залежно від переданого параметра. Замість універсального методу, який містить умови або оператори вибору, створюються окремі функції для кожного конкретного випадку. Це не лише усуває потребу в умовних конструкціях, а й підвищує стабільність програми, адже кожен метод тепер виконує лише одну чітко визначену задачу. Такий підхід спрощує тестування, полегшує супровід коду та покращує його читабельність, оскільки назви методів відразу відображають їхню поведінку.
     Після попереднього етапу рефакторингу код уже став більш структурованим, однак залишалася певна проблема — функція getNextLisState виконувала одразу кілька різних логічних завдань. Вона відповідала і за ініціалізацію початкових даних, і за виконання внутрішніх ітерацій, і за формування фінального результату. Такий підхід робить функцію надто універсальною: її поведінка змінюється залежно від поточного стану, що ускладнює розуміння коду та його подальше тестування. Саме тому доцільно застосувати метод Replace Parameter with Explicit Methods, який допомагає розділити універсальну логіку на кілька чітких і незалежних частин.
     Вигляд коду до застосування методу Replace Parameter with Explicit Methods наведено в додатку В.2.
     У рядках 6–31 видно, що функція містить кілька незалежних гілок, кожна з яких виконує окрему дію: ініціалізацію, обробку наступного кроку або завершення алгоритму. Це порушує принцип єдиної відповідальності — одна функція робить занадто багато. До того ж, тестувати кожен із цих сценаріїв окремо складно, адже вони всі пов’язані через спільну логіку в одному методі.
     Саме тому наступним кроком стало застосування методу Replace Parameter with Explicit Methods, який дозволяє розділити цю функцію на кілька простіших — кожна з них тепер відповідає лише за одну конкретну дію.
     Після проведеного етапу рефакторингу з використанням Replace Parameter with Explicit Methods код став ще більш гнучким і зрозумілим. Як видно з прикладу, функція getNextLisState тепер не містить усієї логіки обробки одразу, а лише визначає, який саме крок алгоритму необхідно виконати, делегуючи обчислення відповідним методам.
     У коді після рефакторингу (код наведено в додатку В.3) з’явилися три окремі функції — initializeState, processInnerLoopStep та moveToNextIteration. Кожна з них відповідає за свою конкретну дію в межах алгоритму пошуку найдовшої зростаючої підпослідовності. Наприклад, у рядках 32–43 функція initializeState виконує лише підготовку початкових даних, створюючи масиви lengths і previousIndex та встановлюючи початкові індекси. У рядках 45–66 метод processInnerLoopStep відповідає виключно за один крок внутрішнього циклу, а в рядках 68–88 функція moveToNextIteration обробляє перехід до наступної ітерації або завершує алгоритм.
     Такий підхід дозволив розділити складну функцію з багатьма умовами на невеликі, логічно завершені частини. Це значно спростило розуміння процесу роботи алгоритму: тепер кожен етап виконання має свій власний метод, який можна легко протестувати окремо. Функція getNextLisState (рядки 90–99) після рефакторингу стала простою точкою керування, що вибирає потрібний сценарій без дублювання коду або заплутаних умов.
     У результаті застосування методу Replace Parameter with Explicit Methods код став модульним, читабельним і простим у розширенні. Замість універсальної функції, яка виконувала все одразу, тепер маємо набір чітко визначених методів, кожен із яких має одну відповідальність і однозначну поведінку. Така структура не лише підвищує якість коду, а й робить подальший розвиток алгоритму більш контрольованим і передбачуваним.
     Наступним методом, який буде розглянуто, є Substitute Algorithm (Заміна алгоритму). Суть цього методу полягає у тому, щоб замінити складний, неефективний або важкий для розуміння алгоритм на більш простий, зрозумілий і продуктивний, зберігаючи при цьому ту саму функціональність програми. Такий підхід дозволяє не лише підвищити ефективність виконання коду, але й зробити його легшим для підтримки та модифікації.
     А тепер перейдемо до практичного прикладу застосування методу Substitute Algorithm. Для демонстрації було використано той самий код, який реалізує алгоритм пошуку найдовшої зростаючої підпослідовності.
     До застосування методу у коді (наведеному в додатку В.3) залишалися кілька неефективних рішень. Зокрема:
• пошук найбільшого елемента у масиві здійснювався за допомогою методу Math.max(...lengths) (рядок 121), що створює новий масив і є ресурсозатратним;
• побудова кінцевої послідовності виконувалася через багаторазове використання unshift, що неефективно при великих об’ємах даних (рядки 123–128);
• а також часто використовувався оператор розпакування ..., який копіює цілі масиви (рядки 93 і 106), що також негативно впливає на продуктивність.
     Після застосування Substitute Algorithm ці ділянки були замінені оптимізованими реалізаціями (змінений код наведено в додатку В.4). Замість виклику Math.max(...) був створений окремий метод findMaxLengthPosition, який знаходить максимальне значення в одному проході циклом, без додаткового створення об’єктів (рядки 69–79). Також замість послідовного додавання елементів через unshift тепер використовується метод buildLISSequence (рядки 81–97), який формує фінальний результат напряму у масив заданої довжини — це робить процес значно швидшим і чистішим.
     У результаті код став не лише ефективнішим, а й зрозумілішим: логіка побудови послідовності винесена в окрему функцію, а всі зайві обчислення були усунені. Це демонструє, як Substitute Algorithm допомагає не просто зробити код коротшим, а й реально підвищити його продуктивність і якість структури.




ВИСНОВКИ

     У процесі дослідження було розглянуто три важливі методи рефакторингу коду — Decompose Conditional, Replace Parameter with Explicit Methods та Substitute Algorithm. Кожен із них спрямований на покращення структури програмного коду, підвищення його читабельності та спрощення подальшої підтримки.
     Застосування цих методів є невід’ємною частиною якісної розробки програмного забезпечення. Вони допомагають не лише усунути надлишкову складність чи дублювання коду, а й зробити логіку роботи програми більш зрозумілою для розробників. Використання Decompose Conditional дозволяє розкласти складні умови на простіші частини, Replace Parameter with Explicit Methods — позбутися зайвих параметрів і умов, а Substitute Algorithm — замінити неефективні рішення на більш оптимальні.
     Отже, рефакторинг за допомогою зазначених методів сприяє створенню чистого, зрозумілого та гнучкого коду, який легше тестувати, розширювати й підтримувати. Використання таких підходів є показником професійності розробника та важливим кроком до підвищення якості програмного продукту.



ДОДАТОК А
Відеозапис

Відеозапис презентації результатів практичної роботи:
https://youtu.be/cje0eKw8uNk

Хронологічний опис відеозапису:
00:00 - Вступне представлення
00:17 – Що таке рефакторинг?
00:52 – Decompose Conditional
01:38 – Код до застосування Decompose Conditional
02:25 - Код після застосування Decompose Conditional
03:04 – Replace Parameter with Explicit Methods
03:48 - Код до застосування Replace Parameter with Explicit Methods
04:21 - Код після застосування Replace Parameter with Explicit Methods
05:14 – Substitute Algorithm
05:31 – Код до застосування Substitute Algorithm
06:15 – Код після застосування Substitute Algorithm
07:14 – Висновок
08:07 – Використані джерела



ДОДАТОК Б
Графічні матеріали


Рисунок Б.1 — Титульний слайд


Рисунок Б.2 — Що таке рефакторинг?


Рисунок Б.3 — Decompose Conditional


Рисунок Б.4 — Код до застосування Decompose Conditional


Рисунок Б.5 — Код після застосування Decompose Conditional


Рисунок Б.6 — Replace Parameter with Explicit Methods


Рисунок Б.7 — Код до застосування Replace Parameter with Explicit Methods


Рисунок Б.8 — Код до застосування Replace Parameter with Explicit Methods


Рисунок Б.9 — Substitute Algorithm


Рисунок Б.10 — Код до застосування Substitute Algorithm


Рисунок Б.11 — Код після застосування Substitute Algorithm


Рисунок Б.12 — Висновок


Рисунок Б.13 — Використані джерела







ДОДАТОК В
Програмний код

В.1 Код до застосування методів рефакторингу
1  export const getNextLisState = (state) => {
 2    const { sequence } = state;
 3    const n = sequence.length;
 4    let { lengths, previousIndex, outerIndex, innerIndex, resultLIS } = { ...state };
 5
 6    if (outerIndex === -1) {
 7      lengths = Array(n).fill(1);
 8      previousIndex = Array(n).fill(-1);
 9      outerIndex = 0;
10      innerIndex = 0;
11    } else if (innerIndex < outerIndex) {
12      if (
13        sequence[innerIndex] < sequence[outerIndex] &&
14        lengths[innerIndex] + 1 > lengths[outerIndex]
15      ) {
16        lengths = [...lengths];
17        previousIndex = [...previousIndex];
18        lengths[outerIndex] = lengths[innerIndex] + 1;
19        previousIndex[outerIndex] = innerIndex;
20      }
21      innerIndex++;
22    } else {
23      outerIndex++;
24      innerIndex = 0;
25
26      if (outerIndex >= n) {
27        let maxPos = lengths.indexOf(Math.max(...lengths));
28        resultLIS = [];
29        while (maxPos !== -1) {
30          resultLIS.unshift(sequence[maxPos]);
31          maxPos = previousIndex[maxPos];
32        }
33        outerIndex = -2;
34      }
35    }
36
37    return {
38      lengths,
39      previousIndex,
40      outerIndex,
41      innerIndex,
42      resultLIS,
43      sequence,
44    };
45  };

В.2 Код після застосування методу Decompose Conditional
1  export const STATE = {
 2    NOT_INITIALIZED: -1,
 3    COMPLETED: -2,
 4  };
 5
 6  const isInitialState = (state) => {
 7    return state.outerIndex === STATE.NOT_INITIALIZED;
 8  };
 9
10  const isProcessingInnerLoop = (state) => {
11    return state.innerIndex < state.outerIndex;
12  };
13
14  const isAlgorithmComplete = (outerIndex, n) => {
15    return outerIndex >= n;
16  };
17
18  const isIncreasingPair = (sequence, j, i) => {
19    return sequence[j] < sequence[i];
20  };
21
22  const canExtendSubsequence = (lengths, j, i) => {
23    return lengths[j] + 1 > lengths[i];
24  };
25
26  const shouldUpdateLIS = (state, sequence) => {
27    const { outerIndex, innerIndex, lengths } = state;
28    return (
29      isIncreasingPair(sequence, innerIndex, outerIndex) &&
30      canExtendSubsequence(lengths, innerIndex, outerIndex)
31    );
32  };
33
34  export const getNextLisState = (state) => {
35    const sequence = state.sequence;
36    const n = sequence.length;
37    let { lengths, previous, outerIndex, innerIndex, resultLIS } = { ...state };
38
39    if (isInitialState(state)) {
40      lengths = Array(n).fill(1);
41      previous = Array(n).fill(-1);
42      outerIndex = 0;
43      innerIndex = 0;
44    } else if (isProcessingInnerLoop(state)) {
45      if (shouldUpdateLIS(state, sequence)) {
46        lengths = [...lengths];
47        previous = [...previous];
48        lengths[outerIndex] = lengths[innerIndex] + 1;
49        previous[outerIndex] = innerIndex;
50      }
51      innerIndex++;
52    } else {
53      outerIndex++;
54      innerIndex = 0;
55
56      if (isAlgorithmComplete(outerIndex, n)) {
57        let maxPos = lengths.indexOf(Math.max(...lengths));
58        resultLIS = [];
59        while (maxPos !== -1) {
60          resultLIS.unshift(sequence[maxPos]);
61          maxPos = previous[maxPos];
62        }
63        outerIndex = STATE.COMPLETED;
64      }
65    }
66
67    return { lengths, previous, outerIndex, innerIndex, resultLIS, sequence };
68  };

В.3 Код після застосування методу Replace Parameter with Explicit Methods
1  const STATE = {
 2    NOT_INITIALIZED: -1,
 3    COMPLETED: -2,
 4  };
 5  
 6  const isInitialState = (state) => {
 7    return state.outerIndex === STATE.NOT_INITIALIZED;
 8  };
 9  
10  const isProcessingInnerLoop = (state) => {
11    return state.innerIndex < state.outerIndex;
12  };
13  
14  const isAlgorithmComplete = (outerIndex, n) => {
15    return outerIndex >= n;
16  };
17  
18  const isIncreasingPair = (sequence, inner, outer) => {
19    return sequence[inner] < sequence[outer];
20  };
21  
22  const canExtendLIS = (lengths, inner, outer) => {
23    return lengths[inner] + 1 > lengths[outer];
24  };
25  
26  const shouldUpdateLIS = (state) => {
27    const { outerIndex, innerIndex, lengths, sequence } = state;
28    return (
29      isIncreasingPair(sequence, innerIndex, outerIndex) &&
30      canExtendLIS(lengths, innerIndex, outerIndex)
31    );
32  };
33  
34  const initializeState = (sequence) => {
35    const n = sequence.length;
36  
37    return {
38      lengths: Array(n).fill(1),
39      previousIndex: Array(n).fill(-1),
40      outerIndex: 0,
41      innerIndex: 0,
42      resultLIS: [],
43      sequence,
44    };
45  };
46  
47  const processInnerLoopStep = (state) => {
48    const { sequence } = state;
49    let { lengths, previousIndex, outerIndex, innerIndex, resultLIS } = {
50      ...state,
51    };
52  
53    if (shouldUpdateLIS(state)) {
54      lengths = [...lengths];
55      previousIndex = [...previousIndex];
56      lengths[outerIndex] = lengths[innerIndex] + 1;
57      previousIndex[outerIndex] = innerIndex;
58    }
59  
60    innerIndex++;
61  
62    return {
63      lengths,
64      previousIndex,
65      outerIndex,
66      innerIndex,
67      resultLIS,
68      sequence,
69    };
70  };
71  
72  const moveToNextIteration = (state) => {
73    const { sequence } = state;
74    const n = sequence.length;
75    let { lengths, previousIndex, outerIndex, resultLIS } = { ...state };
76  
77    outerIndex++;
78    const innerIndex = 0;
79  
80    if (isAlgorithmComplete(outerIndex, n)) {
81      let pos = lengths.indexOf(Math.max(...lengths));
82      resultLIS = [];
83      while (pos !== -1) {
84        resultLIS.unshift(sequence[pos]);
85        pos = previousIndex[pos];
86      }
87      outerIndex = STATE.COMPLETED;
88    }
89  
90    return {
91      lengths,
92      previousIndex,
93      outerIndex,
94      innerIndex,
95      resultLIS,
96      sequence,
97    };
98  };
99  
100 const getNextLisState = (state) => {
101   if (isInitialState(state)) {
102     return initializeState(state.sequence);
103   }
104 
105   if (isProcessingInnerLoop(state)) {
106     return processInnerLoopStep(state);
107   }
108 
109   return moveToNextIteration(state);
110 };

В.4 Код після застосування методу Substitute Algorithm
1  const STATE = {
 2    NOT_INITIALIZED: -1,
 3    COMPLETED: -2,
 4  };
 5  
 6  const isInitialState = (state) => {
 7    return state.outerIndex === STATE.NOT_INITIALIZED;
 8  };
 9  
10  const isProcessingInnerLoop = (state) => {
11    return state.innerIndex < state.outerIndex;
12  };
13  
14  const isAlgorithmComplete = (outerIndex, n) => {
15    return outerIndex >= n;
16  };
17  
18  const isIncreasingPair = (sequence, inner, outer) => {
19    return sequence[inner] < sequence[outer];
20  };
21  
22  const canExtendLIS = (lengths, inner, outer) => {
23    return lengths[inner] + 1 > lengths[outer];
24  };
25  
26  const shouldUpdateLI S = (state) => {
27    const { outerIndex, innerIndex, lengths, sequence } = state;
28    return (
29      isIncreasingPair(sequence, innerIndex, outerIndex) &&
30      canExtendLIS(lengths, innerIndex, outerIndex)
31    );
32  };
33  
34  const findMaxLengthPosition = (lengths) => {
35    let maxLength = 0;
36    let maxPosition = 0;
37  
38    for (let i = 0; i < lengths.length; i++) {
39      if (lengths[i] > maxLength) {
40        maxLength = lengths[i];
41        maxPosition = i;
42      }
43    }
44  
45    return { maxLength, maxPosition };
46  };
47  
48  const buildLISSequence = (lengths, previousIndex, sequence) => {
49    const { maxLength, maxPosition } = findMaxLengthPosition(lengths);
50  
51    const resultLIS = new Array(maxLength);
52    let position = maxPosition;
53    let index = maxLength - 1;
54  
55    while (position !== -1) {
56      resultLIS[index] = sequence[position];
57      position = previousIndex[position];
58      index--;
59    }
60  
61    return resultLIS;
62  };
63  
64  const initializeState = (sequence) => {
65    const n = sequence.length;
66    return {
67      lengths: Array(n).fill(1),
68      previousIndex: Array(n).fill(-1),
69      outerIndex: 0,
70      innerIndex: 0,
71      resultLIS: [],
72      sequence,
73    };
74  };
75  
76  const processInnerLoopStep = (state) => {
77    const { sequence } = state;
78    let { lengths, previousIndex, outerIndex, innerIndex, resultLIS } = {
79      ...state,
80    };
81  
82    if (shouldUpdateLIS(state)) {
83      lengths = [...lengths];
84      previousIndex = [...previousIndex];
85      lengths[outerIndex] = lengths[innerIndex] + 1;
86      previousIndex[outerIndex] = innerIndex;
87    }
88  
89    innerIndex++;
90  
91    return {
92      lengths,
93      previousIndex,
94      outerIndex,
95      innerIndex,
96      resultLIS,
97      sequence,
98    };
99  };
100 
101 const moveToNextIteration = (state) => {
102   const { sequence } = state;
103   const n = sequence.length;
104   let { lengths, previousIndex, outerIndex, resultLIS } = { ...state };
105 
106   outerIndex++;
107   const innerIndex = 0;
108 
109   if (isAlgorithmComplete(outerIndex, n)) {
110     resultLIS = buildLISSequence(lengths, previousIndex, sequence);
111     outerIndex = STATE.COMPLETED;
112   }
113 
114   return {
115     lengths,
116     previousIndex,
117     outerIndex,
118     innerIndex,
119     resultLIS,
120     sequence,
121   };
122 };
123 
124 const getNextLisState = (state) => {
125   if (isInitialState(state)) {
126     return initializeState(state.sequence);
127   }
128 
129   if (isProcessingInnerLoop(state)) {
130     return processInnerLoopStep(state);
131   }
132 
133   return moveToNextIteration(state);
134 };







