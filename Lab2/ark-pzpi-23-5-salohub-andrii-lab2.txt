МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ




Звіт
з лабораторної роботи № 2 з дисципліни
Аналіз та рефакторинг коду





Виконала:                                                                         Перевірив:
ст. гр. ПЗПІ-23-5                        				ст. викладач кафедри ПІ
Салогуб Андрій Сергійович 				          Сокорчук Ігор Петрович









Харків 2025


1 ІСТОРІЯ ЗМІН

№
Версія звіту
Опис змін та виправлень
1
0.1
Створено розділ “Історія змін”


      


2 ЗАВДАННЯ

   Завдання:
1. Розробити будову програмної системи.
2. Створити UML діаграму прецедентів для серверної частини системи.
3. Створити ER діаграму даних.
4. Розробити базу даних (БД) програмної системи.
5. Створити діаграму структури БД.
6. Розробити функції роботи з БД (ORM або CoRM тощо).
7. Розробити API (REST або GraphQL, gRPC тощо) для взаємодії серверної частини з клієнтами.
8. Створити специфікацію розробленого API.
9. Створити програмну реалізацію розробленого API та функцій роботи з БД.
10. Перевірити роботу створеного програмного коду серверної частини системи.
11. Завантажити або оновити (при потребі) створений програмний код у GitHub репозиторій для лабораторних робіт у гілку репозиторію main.
12. Створити відеозапис тривалістю 7-9 хвилин з демонстрацією перевірки (тестування) описаної у розділі 3.1 Vision & Scope функціональності серверної частини.
13. Завантажити створений відеозапис у свій канал для облікового запису студента в домені nure.ua на YouTube. При завантаженні відеозапису обовʼязково встановити у налаштуваннях для цього відео українську мову як мову відео та мову субтитрів до відео.
14. Створити хронологічний опис (хвилина:секунда) демонстрації та додати цей опис до опису відео на YouTube.
15. Створити звіт до лабораторної роботи.
16. Вказати у звіті посилання на створений відеозапис на YouTube
17. Експортувати створений звіт у формат PDF та завантажити його на платформу dl.nure.ua
18. Експортувати увесь створений звіт у текстовий файл з кодуванням UTF-8 та записати цей файл у GitHub репозиторій для лабораторних робіт.



3 ОПИС ВИКОНАНОЇ РОБОТИ

	Програмна система реалізована як серверна частина у вигляді REST API-додатку. Для розробки використано платформу Node.js, мову TypeScript та фреймворк Express.js. В якості бази даних було обрано PostgreSQL. Робота з даними здійснюється через сучасний Drizzle ORM. Аутентифікація користувачів виконана за допомогою JWT-токенів, які передаються в httpOnly-куках, а також передбачена обов’язкова верифікація електронної пошти. Система складається з кількох основних модулів: автентифікація та управління користувачами, робота з автомобілями, події та історія власності, генерація звітів по VIN, а також зарезервовані модулі для майбутньої інтеграції IoT-пристроїв. Уся взаємодія з клієнтськими додатками буде відбуватися через єдиний REST-інтерфейс.
     ER-діаграма розроблена з урахуванням нормалізації до третьої нормальної форми. Визначено основні сутності: користувач, автомобіль, зв’язкова таблиця історії власності, події пов’язані з автомобілем, перевірки по VIN, коди верифікації електронної пошти, а також зарезервовані сутності для телеметрії та алертів IoT-пристроїв. Ключові зв’язки між сутностями реалізовано через зовнішні ключі з каскадним видаленням. Один користувач може володіти багатьма автомобілями в різний час, один автомобіль може мати багато подій та багато записів про перевірки. Схема наведена на рисунку 1.
     Фізична модель бази даних відображає точні назви стовпців, їх типи даних, обмеження первинних та зовнішніх ключів, а також напрямки зв’язків між таблицями. На діаграмі чітко видно співвідношення один-до-багатьох та багато-до-багатьох, позначені nullable поля та значення за замовчуванням. Схема наведена на рисунку 2.
     Діаграма прецедентів відображає всіх основних акторів системи та їх взаємодію з серверною частиною. Серед акторів виділено неавторизованого користувача, авторизованого користувача та адміністратора. Неавторизований користувач має можливість реєструватися, входити в систему. Авторизований користувач може переглядати шукати автомобілі за VIN-кодом, додавати свої автомобілі, оновлювати їх дані, переглядати історію перевірок та отримувати звіти, він також має право редагувати інформацію лише про ті транспортні засоби, якими володіє на поточний момент. Адміністратор володіє можливістю блокування, розблокювання користувачів та перегляд усіх даних. Схема наведена на рисунку 3.
     Для роботи з базою даних обрано Drizzle ORM — сучасний типобезпечний ORM для TypeScript, який забезпечує повну інтеграцію типів бази даних у код. Усі операції створення, читання, оновлення та видалення винесено у відповідні сервіси. Завдяки Drizzle ORM запити пишуться майже як звичайний SQL, але з повним автодоповненням та перевіркою типів під час компіляції. Використовуються відношення для зручного отримання пов’язаних даних одним запитом. Для під’єднання до бази даних виконується код наведений нижче (рядки 1-17), cпочатку завантажуються змінні оточення з файлу .env (рядок 6). Потім створюється пул з'єднань до PostgreSQL за допомогою бібліотеки pg. У налаштуваннях пулу береться URL бази даних із змінної оточення (рядок 9).Далі об'єкт цього пулу передається в drizzle (рядок 15), і разом із імпортованою схемою бази даних створюється готовий об'єкт db. Цей db потім експортується і використовується в усьому проєкті для всіх запитів до бази даних. 
1  import { Pool } from 'pg';
2  import { drizzle } from 'drizzle-orm/node-postgres';
3  import dotenv from 'dotenv';
4  import * as schema from './schema';
6  dotenv.config();
8  const pool = new Pool({
9    connectionString: process.env.DATABASE_URL!,
10   ssl: {
11     rejectUnauthorized: false,
12   },
13 });
15 const db = drizzle(pool, { schema });
17 export { db };

     Прикладом створення таблиць в Drizzle ORM є код наведений нижче (рядки 1-18):
1   import { pgTable, uuid, varchar, boolean, timestamp } from 'drizzle-orm/pg-core';
3   export const users = pgTable('users', {
4     id: uuid('id').primaryKey().defaultRandom(),
5     email: varchar('email', { length: 255 }).notNull().unique(),
6     passwordHash: varchar('password_hash', { length: 255 }),
7     googleId: varchar('google_id', { length: 255 }).unique(),
8     firstName: varchar('first_name', { length: 100 }),
9     lastName: varchar('last_name', { length: 100 }),
10    role: varchar('role', { length: 20 }).notNull().default('user'),
11    isBlocked: boolean('is_blocked').notNull().default(false),
12    emailVerified: boolean('email_verified').notNull().default(false),
13    createdAt: timestamp('created_at').notNull().defaultNow(),
14    updatedAt: timestamp('updated_at')
15      .notNull()
16      .defaultNow()
17      .$onUpdate(() => new Date()),
18  });

     Реалізація розробленого API виконана у вигляді чистої, модульної архітектури з чітким поділом відповідальностей. Кожен модуль містить контролер, сервіс та маршрути. Код написаний з використанням строгої типізації, з повним захистом від null/undefined. Можна виділити деякі частини реалізованого кодую. Наприклад, перша — автоматична детекція скрутки пробігу при оновленні автомобіля (рядки 1-12). Коли власник намагається вказати менший пробіг, ніж був раніше — система не просто блокує операцію, а створює спеціальну подію типу mileage_tampering з високим рівнем небезпеки та автоматично підвищує ризик-скоринг автомобіля. Ось як це реалізовано:
1  if (data.currentMileage < oldMileage) {
2          await db.insert(carEvents).values({
3            carId,
4            eventType: 'mileage_tampering',
5            severity: 'high',
6            description: `Mileage rollback detected: ${oldMileage} → ${data.currentMileage} km`,
7            mileage: data.currentMileage,
8            eventDate: new Date(),
9            verifiedByIot: false,
10         });
11         await this.updateRiskScore(carId);
12 }

     Друга частина цього — автоматична генерація рекомендацій покупцеві на основі ризик-скору та критичних подій (рядки 1-32). Система сама аналізує дві найнебезпечніші речі — скрутку пробігу та високий ризик-скор (90+ балів) — і одразу видає чітку рекоментацію щодо того слід купляти чи ні. Навіть якщо скору трохи нижче, але є серйозні аварії — буде «високий ризик, обов’язкова діагностика».Це зрозуміла порада покупцеві: від зеленого «можна брати» до червоного «не розглядати моживість покупки цього автомобіля». 
1  private generateRecommendations(report) {
2    const recs: Array<{ severity: 'low' | 'medium' | 'high' | 'critical'; message: string }> = [];
3    const riskScore = report.car?.riskScore ?? 0;
4    const events = report.events ?? [];
5    const hasTampering = events.some((e) => e.eventType === 'mileage_tampering');
6    const hasAccidents = events.some(
7      (e) => e.eventType === 'accident' && e.severity === 'high'
8    );
10   if (riskScore >= 90 || hasTampering) {
11     recs.push({
12       severity: 'critical',
13       message: 'DO NOT BUY: Mileage tampering or critical risk detected',
14     });
15   } else if (riskScore >= 60 || hasAccidents) {
16     recs.push({
17       severity: 'high',
18       message: 'High risk. Professional inspection required',
19     });
20   } else if (riskScore >= 30) {
21     recs.push({
22       severity: 'medium',
23       message: 'Moderate risk. Check history carefully',
24     });
25   } else {
26     recs.push({
27       severity: 'low',
28       message: 'No major issues found. Vehicle appears clean',
29     });
30   }
31   return recs;
32 }

     Специфікація створена безпосередньо у коді за допомогою JSDoc-коментарів і автоматично генерується у інтерактивному Swagger UI (вигляд наведено на рисунку 4). Всі ендпоінти описані і мають приклади запитів, відповідей, схемами даних, можливими помилками та поясненнями. Визначено окремі компоненти схем для автомобіля, користувача, події, звіту та рекомендацій. Документація доступна за шляхом /api/docs і є повноцінним технічним довідником для фронтенду та майбутніх інтеграцій.









4 ВИСНОВКИ
  У ході виконання лабораторної роботи було успішно розроблено та реалізовано повноцінну серверну частину системи перевірки історії автомобілів за VIN-кодом. Створено масштабовану, типобезпечну архітектуру на базі Node.js, TypeScript та Express.js з використанням сучасного Drizzle ORM та PostgreSQL. Реалізована надійна система аутентифікації з JWT-токенами, httpOnly-куками та обов’язковою верифікацією електронної пошти. Розроблено детальну модель даних з нормалізацією до третьої нормальної форми, що забезпечує цілісність та ефективність зберігання інформації про автомобілі, власників, події та перевірки.
  Запроваджено інтелектуальні механізми захисту від шахрайства, зокрема автоматичне виявлення скручування пробігу з фіксацією події та підвищенням ризику, а також розумну систему оцінки ризиків з чіткими рекомендаціями покупцеві — від «можна купувати» до «категорично не рекомендується». Реалізовано гнучку модель монетизації через різні типи звітів (basic, extended, premium) з обмеженням доступу до конфіденційних даних.
  Створено чисте, добре документоване REST API зі Swagger-документацією, повною типізацією та чітким поділом відповідальностей між контролерами та сервісами. Увесь код розміщено у GitHub-репозиторії, протестовано, задокументовано у відео та звіті. 



ДОДАТОК А
Відеозапис

Відеозапис презентації результатів лабораторної роботи:
https://youtu.be/uhfKJk1UkQ8

Хронологічний опис відеозапису:
00:00 - Представлення
00:06 - Завдання, яке потрібно було виконати
00:12 - Пояснення схеми розробленої бази даних
00:45 - Як відбувається підключення до бази даних
01:09 - Приклад описаної схеми в Drizzle ORM
01:19 - Специфікація створеного API
01:55 - Наповнення бази даних до тестування API
02:07 - Тестування функціоналу реєстації та підтвердження пошти
03:00 - Тестування функціоналу входу
03:26 - Створення нового автомобілю
03:59 - Додавання події для автомобіля
04:33 - Отримання інформації про автомобіль за VIN-кодом
05:00 - Зміна пробігу автомобіля, автоматичне додавання події скручення та підвищення ризику
06:11 - Отримання всіх подій, які відбувались з автомобілем
06:34 - Дії з профілем користувача
07:09 - Отримання звіту про автомобіль


ДОДАТОК Б
Графічні матеріали


Рисунок 1 — ER-діаграма


Рисунок 2 — Діаграма структури бази даних

Рисунок 3 — UML діаграма прецедентів


Рисунок 4 — Cпецифікація розробленого API


     



1



