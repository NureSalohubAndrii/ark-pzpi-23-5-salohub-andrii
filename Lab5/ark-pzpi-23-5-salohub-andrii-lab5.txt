МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ




Звіт
з лабораторної роботи № 5 з дисципліни
Аналіз та рефакторинг коду





Виконала:                                                                         Перевірив:
ст. гр. ПЗПІ-23-5                        				ст. викладач кафедри ПІ
Салогуб Андрій Сергійович 				          Сокорчук Ігор Петрович









Харків 2025


1 ІСТОРІЯ ЗМІН

№
Версія звіту
Опис змін та виправлень
1
0.1
Створено розділ “Історія змін”


      


2 ЗАВДАННЯ

   Завдання:
1. Розгорнути реалізовану програмну систему.
2. Перевірити та налаштувати роботу розгорнутої програмної системи.
3. Продемонструвати описану у розділі 2.2 Vision & Scope функціональність програмної системи.
4. Створити відеозапис демонстрації функціональності та завантажити його у свій канал на YouTube.  При завантаженні відеозапису потрібно обовʼязково встановити у налаштуваннях для цього відео українську мову як мову відео та мову субтитрів до відео.
5. Створити хронологічний опис (хвилина:секунда) демонстрації та додати цей опис до опису відео.
6. Створити звіт до лабораторної роботи;
7. Експортувати створений звіт у формат PDF та завантажити його на платформу dl.nure.ua.
8. Експортувати увесь створений звіт у текстовий файл з кодуванням UTF-8 та записати цей файл у GitHub репозиторій для лабораторних робіт у гілку репозиторію main.



3 ОПИС ВИКОНАНОЇ РОБОТИ

     Для забезпечення відтворюваності та простоти розгортання застосунок контейнеризовано з використанням Docker та Docker Compose.
     Архітектура розгортання складається з двох основних компонентів:
• Backend-сервер (Bun + TypeScript);
• База даних PostgreSQL (локально в Docker або зовнішній сервіс).
     Компоненти взаємодіють між собою через внутрішню Docker-мережу або стандартне TCP-зʼєднання у випадку зовнішньої БД.
     Файл Dockerfile відповідає за збірку контейнера з серверною частиною застосунку.
1  FROM oven/bun:latest
3  WORKDIR /app
5  COPY package.json bun.lock ./
7  RUN bun install
9  COPY . .
11 EXPOSE 3000
13 CMD ["sh", "-c", "bun run db:push:dev && bun run dev"]

     У першому рядку Dockerfile (ряд. 1) використовується базовий образ oven/bun, який містить готове середовище виконання для Bun. Це дозволяє уникнути ручного налаштування середовища всередині контейнера. У рядках 3–7 задається робоча директорія контейнера та виконується копіювання лише файлів залежностей із подальшим встановленням пакетів. Такий підхід дозволяє Docker ефективно кешувати шар із залежностями. У рядках 9–10 копіюється повний вихідний код застосунку. У рядку 11 відкривається порт 3000, який використовується сервером. Особливо важливим є рядок 13, де перед запуском сервера виконується команда синхронізації структури бази даних. Це гарантує, що сервер запускається лише після приведення схеми БД у актуальний стан.
     Особливу увагу в процесі розгортання програмної системи приділено Bash-скрипту автоматизації, який виконує роль єдиної точки входу для підготовки середовища та запуску застосунку. Метою створення цього скрипта було зменшення кількості ручних дій з боку користувача та мінімізація типових помилок, що виникають під час налаштування серверних застосунків.
     Скрипт починає виконання з виведення інформаційного повідомлення та перевірки критично важливих залежностей. Першим таким елементом є Bun - середовище виконання серверної частини застосунку.
1 if ! command -v bun &> /dev/null; then
2     echo "Bun не знайдено!"
3     echo "Він потрібен для роботи сервера."
4     exit 1
5 else
6     echo "Bun встановлено ($(bun -v))"
7 fi

     У наведеному фрагменті (рядки 1–7) використовується перевірка наявності виконуваного файлу bun у системі. Якщо Bun відсутній, скрипт завершує роботу, не дозволяючи перейти до наступних етапів. Це рішення запобігає ситуації, коли користувач намагається запустити сервер у некоректно підготовленому середовищі.
     Далі скрипт переходить до конфігураційного етапу, під час якого створюється або перевикористовується файл .development.env. На цьому етапі реалізовано інтерактивну логіку, яка дозволяє обрати тип бази даних - локальну у Docker або зовнішню хмарну. Вибір користувача впливає на подальшу поведінку скрипта, зокрема на необхідність перевірки Docker та запуск контейнерів.
     Цікавим моментом є обробка вже існуючого конфігураційного файлу. Якщо файл .development.env знайдено, скрипт аналізує його вміст і визначає, який тип бази даних використовується.
1 if grep -q "DATABASE_URL" "$ENV_FILE"; then
2     db_url=$(grep "DATABASE_URL" "$ENV_FILE" | cut -d'=' -f2)
3     if [[ "$db_url" == *"localhost"* ]]; then
4         USE_LOCAL_DB=true
5     else
6         USE_LOCAL_DB=false
7     fi
8 fi

     У цьому фрагменті (рядки 1–8) тип бази даних визначається на основі значення DATABASE_URL. Якщо в URL присутній localhost, система автоматично переходить у режим локальної бази даних. Таким чином, скрипт не лише створює конфігурацію, а й уміє адаптуватися до вже наявних налаштувань.
     У разі використання локальної бази даних скрипт виконує перевірку наявності Docker та його активного стану. Це дозволяє виявити типову проблему, коли Docker встановлений, але не запущений.
1 if ! docker info &> /dev/null; then
2     echo "Docker встановлено, але не запущений!"
3     exit 1
4 fi

     Наступним важливим етапом є перевірка зайнятості порту PostgreSQL. Скрипт визначає порт із рядка підключення до бази даних та перевіряє, чи не використовується він іншим процесом.
1 if lsof -i :$DB_PORT &> /dev/null; then
2     echo "Порт $DB_PORT вже зайнятий"
3 fi

     У разі конфлікту портів користувачу пропонується автоматично зупинити локальний PostgreSQL або завершити процес, що займає порт. Така поведінка значно спрощує роботу у середовищі розробки, де часто вже встановлені локальні сервіси.
     Після успішної перевірки середовища скрипт переходить до запуску контейнера з базою даних та очікування її готовності.
1 docker-compose up -d db
2
3 for i in {1..30}; do
4     if docker exec car-history-db pg_isready -U ${POSTGRES_USER} &> /dev/null; then
5         break
6     fi
7     sleep 1
8 done

     У цьому фрагменті (рядки 1–8) реалізовано активне очікування готовності PostgreSQL. Сервер не запускається доти, доки база даних не почне приймати підключення, що усуває типову проблему старту сервера раніше за БД.
     Фінальним етапом роботи скрипта є синхронізація структури бази даних та запуск серверної частини застосунку.
1 bun run db:push:dev
 2 bun run dev





4 ВИСНОВКИ

     У ході виконання лабораторної роботи було успішно розгорнуто програмну систему Car History у контейнеризованому середовищі. Реалізований процес розгортання базується на використанні Docker, Docker Compose та автоматизованого Bash-скрипта, що дозволило забезпечити відтворюваність середовища, зменшити кількість ручних дій та мінімізувати ймовірність помилок під час налаштування.



ДОДАТОК А
Відеозапис

Відеозапис презентації результатів лабораторної роботи: https://youtu.be/9JTg90xLMC8

Хронологічний опис відеозапису:
00:00 - Представлення
00:07 - Завдання, яке потрібно було виконати
00:14 - Початковий стан системи
00:24 - Початок розгортання системи
00:40 - Розгортання бази даних
01:00 - Налаштування змінних довкілля
01:27 - Встановлення бібліотек
01:43 - Запуск сервера
01:49 - Перевірка налаштувань
02:02 - Перевірка бази даних
02:20 - Демонстрація специфікації
02:34 - Тестування функціоналу реєстація, авторизації та додавання автомобілю на розгорнутій системі
04:00 - Підключення до зовнішньої бази даних
04:47 - Тестування функціоналу адміністрування
06:50 - Тестування IoT клієнта



1



